const mongoose = require('mongoose');

const questionSchema = new mongoose.Schema({
  content: {
    type: String,
    required: [true, 'Question content is required'],
    trim: true,
    minlength: [10, 'Question content must be at least 10 characters'],
    maxlength: [1000, 'Question content cannot exceed 1000 characters']
  },
  options: [{
    type: String,
    required: [true, 'Question options are required'],
    trim: true,
    minlength: [1, 'Option cannot be empty'],
    maxlength: [200, 'Option cannot exceed 200 characters']
  }],
  correctAnswer: {
    type: String,
    required: [true, 'Correct answer is required'],
    trim: true,
    validate: {
      validator: function(value) {
        return this.options.includes(value);
      },
      message: 'Correct answer must be one of the provided options'
    }
  },
  explanation: {
    type: String,
    required: [true, 'Explanation is required'],
    trim: true,
    minlength: [10, 'Explanation must be at least 10 characters'],
    maxlength: [2000, 'Explanation cannot exceed 2000 characters']
  },
  category: [{
    type: String,
    required: [true, 'At least one category is required'],
    trim: true,
    minlength: [1, 'Category cannot be empty'],
    maxlength: [50, 'Category cannot exceed 50 characters']
  }],
  difficulty: {
    type: Number,
    required: [true, 'Difficulty level is required'],
    min: [1, 'Difficulty must be at least 1'],
    max: [10, 'Difficulty cannot exceed 10'],
    validate: {
      validator: Number.isInteger,
      message: 'Difficulty must be an integer'
    }
  },
  difficultyLevel: {
    type: String,
    enum: ['easy', 'medium', 'hard'],
    required: [true, 'Difficulty level (easy, medium, hard) is required'],
    default: 'medium'
  },
  adminApproved: {
    type: Boolean,
    default: false
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: [30, 'Tag cannot exceed 30 characters']
  }],
  hints: [{
    type: String,
    trim: true,
    maxlength: [500, 'Hint cannot exceed 500 characters']
  }],
  generatedBy: {
    type: String,
    enum: {
      values: ['AI', 'Human'],
      message: 'Generated by must be either AI or Human'
    },
    required: [true, 'Generation source is required']
  },
  validationScore: {
    type: Number,
    min: [0, 'Validation score cannot be negative'],
    max: [1, 'Validation score cannot exceed 1'],
    default: 0.8
  },
  timesUsed: {
    type: Number,
    default: 0,
    min: [0, 'Times used cannot be negative']
  },
  averageTimeSpent: {
    type: Number,
    default: 0,
    min: [0, 'Average time spent cannot be negative']
  },
  successRate: {
    type: Number,
    default: 0,
    min: [0, 'Success rate cannot be negative'],
    max: [1, 'Success rate cannot exceed 1']
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for performance optimization
questionSchema.index({ category: 1, difficulty: 1 });
questionSchema.index({ generatedBy: 1, createdAt: -1 });
questionSchema.index({ tags: 1 });
questionSchema.index({ 'category.0': 1, difficulty: 1 }); // First category + difficulty

// Virtual for category hierarchy depth
questionSchema.virtual('categoryDepth').get(function() {
  return this.category.length;
});

// Virtual for primary category (first in hierarchy)
questionSchema.virtual('primaryCategory').get(function() {
  return this.category[0];
});

// Pre-validate middleware for syncing difficulty
questionSchema.pre('validate', function(next) {
  // Sync numerical difficulty based on difficultyLevel
  if (this.difficultyLevel) {
    const diffMap = {
      'easy': 3,
      'medium': 5,
      'hard': 8
    };
    // Only update if difficulty is not explicitly set or needs sync
    if (!this.difficulty || this.isModified('difficultyLevel')) {
      this.difficulty = diffMap[this.difficultyLevel];
    }
  }
  next();
});

// Pre-save middleware for validation and tagging
questionSchema.pre('save', function(next) {
  // Ensure options array has at least 2 options and at most 6
  if (this.options.length < 2) {
    return next(new Error('Question must have at least 2 options'));
  }
  if (this.options.length > 6) {
    return next(new Error('Question cannot have more than 6 options'));
  }

  // Ensure no duplicate options
  const uniqueOptions = [...new Set(this.options)];
  if (uniqueOptions.length !== this.options.length) {
    return next(new Error('Question options must be unique'));
  }

  // Validate category hierarchy (should be ordered from general to specific)
  if (this.category.length === 0) {
    return next(new Error('Question must have at least one category'));
  }

  // Validate category hierarchy structure
  const validationResult = this.validateCategoryHierarchy();
  if (!validationResult.isValid) {
    return next(new Error(validationResult.error));
  }

  // Auto-generate tags based on category hierarchy and content
  this.generateTags();

  next();
});

// Static method to find questions by category and difficulty range
questionSchema.statics.findByCategoryAndDifficulty = function(categories, minDifficulty, maxDifficulty, limit = 10) {
  return this.find({
    category: { $in: categories },
    difficulty: { $gte: minDifficulty, $lte: maxDifficulty }
  })
  .sort({ createdAt: -1 })
  .limit(limit);
};

// Static method to find questions by category hierarchy
questionSchema.statics.findByCategoryHierarchy = function(categoryPath, exactMatch = false, limit = 10) {
  let query;
  
  if (exactMatch) {
    // Exact hierarchy match
    query = { category: categoryPath };
  } else {
    // Find questions that contain all categories in the path (in order)
    query = {
      $and: categoryPath.map((cat, index) => ({
        [`category.${index}`]: cat
      }))
    };
  }

  return this.find(query)
    .sort({ difficulty: 1, createdAt: -1 })
    .limit(limit);
};

// Static method to get questions for adaptive learning
questionSchema.statics.getAdaptiveQuestions = function(learnerProfile, excludeIds = [], limit = 5) {
  const query = {
    _id: { $nin: excludeIds }
  };

  // Add category filtering based on learner's weak areas
  if (learnerProfile.weakAreas && learnerProfile.weakAreas.length > 0) {
    query.category = { $in: learnerProfile.weakAreas };
  }

  // Add difficulty filtering based on learner's preference
  if (learnerProfile.difficultyPreference) {
    const diffRange = 2; // Allow Â±2 difficulty levels
    query.difficulty = {
      $gte: Math.max(1, learnerProfile.difficultyPreference - diffRange),
      $lte: Math.min(10, learnerProfile.difficultyPreference + diffRange)
    };
  }

  return this.find(query)
    .sort({ timesUsed: 1, createdAt: -1 }) // Prefer less used questions
    .limit(limit);
};

// Instance method to validate category hierarchy
questionSchema.methods.validateCategoryHierarchy = function() {
  // Categories should be ordered from general to specific
  // e.g., ["Mathematics", "Algebra", "Linear Equations", "Systems of Equations"]
  
  if (this.category.length === 0) {
    return { isValid: false, error: 'Question must have at least one category' };
  }

  // Check for empty categories
  for (let i = 0; i < this.category.length; i++) {
    if (!this.category[i] || this.category[i].trim() === '') {
      return { isValid: false, error: `Category at position ${i + 1} cannot be empty` };
    }
  }

  // Check for duplicate categories in hierarchy
  const uniqueCategories = [...new Set(this.category)];
  if (uniqueCategories.length !== this.category.length) {
    return { isValid: false, error: 'Category hierarchy cannot contain duplicates' };
  }

  // Validate hierarchy depth (max 5 levels)
  if (this.category.length > 5) {
    return { isValid: false, error: 'Category hierarchy cannot exceed 5 levels' };
  }

  // Check for proper hierarchy structure (each level should be more specific)
  // This is a basic check - in a real system, you might have a predefined taxonomy
  for (let i = 1; i < this.category.length; i++) {
    if (this.category[i].length <= this.category[i-1].length) {
      // This is a heuristic - more specific categories tend to be longer
      // In practice, you'd validate against a predefined category tree
      console.warn(`Category hierarchy may not be properly ordered: ${this.category[i-1]} -> ${this.category[i]}`);
    }
  }

  return { isValid: true };
};

// Instance method to generate tags based on category and content
questionSchema.methods.generateTags = function() {
  const generatedTags = new Set();

  // Add category-based tags
  this.category.forEach(cat => {
    // Add the category itself
    generatedTags.add(cat.toLowerCase());
    
    // Add individual words from multi-word categories
    const words = cat.split(/\s+/).filter(word => word.length > 2);
    words.forEach(word => generatedTags.add(word.toLowerCase()));
  });

  // Add difficulty-based tags
  if (this.difficulty <= 3) {
    generatedTags.add('beginner');
  } else if (this.difficulty <= 6) {
    generatedTags.add('intermediate');
  } else {
    generatedTags.add('advanced');
  }

  // Add generation source tag
  generatedTags.add(this.generatedBy.toLowerCase());

  // Extract keywords from question content (simple approach)
  const contentWords = this.content.toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 3 && !['what', 'which', 'when', 'where', 'why', 'how', 'the', 'and', 'or', 'but', 'for', 'with', 'from', 'this', 'that', 'these', 'those'].includes(word));
  
  contentWords.slice(0, 5).forEach(word => generatedTags.add(word)); // Limit to 5 content-based tags

  // Merge with existing tags, avoiding duplicates
  const existingTags = new Set(this.tags.map(tag => tag.toLowerCase()));
  const allTags = new Set([...existingTags, ...generatedTags]);
  
  this.tags = Array.from(allTags).slice(0, 15); // Limit total tags to 15
};

// Instance method to update usage statistics
questionSchema.methods.updateUsageStats = function(timeSpent, wasCorrect) {
  this.timesUsed += 1;
  
  // Update average time spent
  this.averageTimeSpent = ((this.averageTimeSpent * (this.timesUsed - 1)) + timeSpent) / this.timesUsed;
  
  // Update success rate
  const previousCorrectAnswers = Math.round(this.successRate * (this.timesUsed - 1));
  const newCorrectAnswers = previousCorrectAnswers + (wasCorrect ? 1 : 0);
  this.successRate = newCorrectAnswers / this.timesUsed;
  
  return this.save();
};

module.exports = mongoose.model('Question', questionSchema);